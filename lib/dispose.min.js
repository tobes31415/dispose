const s=Symbol("Dispose Callbacks"),e=Symbol("Is Disposed"),o=Symbol("Force recursive dispose");function r(s){try{s()}catch(s){console.error("Error occured during dispose: "+s)}}function i(s,e){Array.isArray(s)?s.forEach(e):i(Object.values(s),e)}export function isDisposed(s){return!!s[e]};export function dispose(o){isDisposed(o)||(o[e]=!0,o[s]?o[s].forEach(r):i(o,dispose))};export function onDispose(e,o){isDisposed(e)?r(o):(e[s]||(e[s]=[]),e[s].push(o))};export function onDisposeDisposeRecursively(s){s[o]||(s[o]=!0,onDispose(s,()=>i(s,dispose)))};export function onDisposeChain(s,e){onDispose(s,()=>dispose(e))};export function assertNotDisposed(s,e){if(isDisposed(s))throw new Error(e||"Object has been disposed")};export function createDisposeableFunctionWrapper(s,e,o=!1){if(!s)throw new Error("fnRef is required");if(e&&o)throw new Error("message and silent are mutually exclusive");const r=(...i)=>{if(o){if(isDisposed(r))return}else assertNotDisposed(r,e);return s.apply(this,i)};return r};