const s=Symbol("Dispose Callbacks"),e=Symbol("Is Disposed"),o=Symbol("Force recursive dispose");function i(s){try{s()}catch(s){console.error("Error occured during dispose: "+s)}}function r(s,e){Array.isArray(s)?s.forEach(e):r(Object.values(s),e)}export function isDisposed(s){return!!s[e]};export function dispose(o){isDisposed(o)||(o[e]=!0,o[s]?o[s].forEach(i):r(o,dispose))};export function onDispose(e,o){isDisposed(e)?i(o):(e[s]||(e[s]=[]),e[s].push(o))};export function onDisposeDisposeRecursively(s){s[o]||(s[o]=!0,onDispose(s,()=>r(s,dispose)))};export function onDisposeChain(s,e){onDispose(s,()=>dispose(e))};export function assertNotDisposed(s,e="Object has been disposed"){if(isDisposed(s))throw new Error(e)};export function createDisposeableFunctionWrapper(s,e="Function has been disposed",o=!1){if(!s)throw new Error("fnRef is required");if(e&&"Function has been disposed"!==e&&o)throw new Error("message and silent are mutually exclusive");const i=(...r)=>{if(o){if(isDisposed(i))return}else assertNotDisposed(i,e);return s.apply(this,r)};return i};